# CPP
- [OOP(Object-Oriented Programming)](#OOP)
- [Class](#Class)
- [auto](#auto)
- [Reference vs Copy](#Reference-vs-Copy)

---
## OOP
### 절차적 프로그래밍?
- 프로그램 설계 시 기능 구현을 위해 프로시저(함수)를 중점으로 사용하여 구조/로직을 설계하는 방법

### 객체지향(OOP)?
- 프로그램 설계 시 프로그램을 수많은 객체로 나누고 이 객체들의 상호작용으로 설계하는 방법

### 장점
- 코드 재사용이 용이하다, 객체를 만들어두면 재사용할 수 있다
- 클래스 기능별로 분할하였기 때문에 모듈화도 용이하다
- 상속을 통해 높은 확장성을 가질 수 있다
- 즉, 유지보수성이 뛰어나다

### 특징
- Encapsulation (캡슐화)
    - 클래스를 통해 변수와 함수를 하나의 단위로 묶는다
    - 하나의 기능을 하는 요소들은 모두 한 캡슐에 모아두는 것
    - 같은 역할을 하는 변수, 함수들을 모아두었기 때문에 의존성, 커플링이 줄어든다
    - 즉, 관리가 용이해진다

- Information hiding (정보은닉)
    - 프로그램의 세부구현을 감추는 것
    - private을 통해 변수와 객체를 감추고, public으로 선언된 메소드로만 접근을 허용하여 제한하는 것
    - Why?
        - 의도하지 않은 접근을 제한하기 위해 (= 설계한 클래스를 다른 사람이, 혹은 본인이 잘못 쓰는 것을 방지)
        - 이러한 코드 사용자는 프로그램의 내부 구현에 신경 쓸 필요없이 메소드를 통해 원하는 기능을 호출
    - 객체들끼리 서로의 구현과 상태를 상관하지 않고 단지 사용하게만 함으로써 의존성을 낮추는 역할을 한다

- Inheritance (상속)
    - 자식 클래스가 부모 클래스의 변수, 함수를 물려받는 것
    - 자식 클래스는 자식만의 특성을 오버라이딩을 통해 구현한다
    - Why?
        - 다형성과도 연관되는 질문으로, 부모와 자식을 다형성으로 엮어놓으면 부모에서 추상적인 형태를 주고,  
        자식에서 세밀화하여 유연하게 코드를 작성할 수 있으며 생상성, 유지보수성 또한 올라간다 (무분별한 복붙을 막을 수 있는 효과)
        - 추후 기능개선 시 `교체`가 가능하다
        - 복붙으로 이루어진 코드들은 제각기 다른 코드이므로 개선이 필요할 때 구현을 따로따로 해줘야 하므로 유지보수가 어렵다

- Abstraction (추상화)
    - 공통의 속성이나 기능을 묶어 이름을 붙이는 것

## Class

### Class?
- CPP에서 객체를 구현하기 위해 사용하는 방법으로 변수와 메서드를 가진 사용자 정의 자료형
- 객체의 상태/특성을 정의하는 일종의 설계도이며, 객체화했을때(인스턴스) 객체가 된다
- 정적/동적 할당으로 실제 메모리에 해당 자료형으로 만든 영역이 할당되었을 때 하나하나를 객체(인스턴스)라고 한다

### Instance?
- 클래스를 기반으로 만들어져 실제로 메모리에 할당된 것

### Byte Padding
- 구조체나 클래스를 실제로 메모리에 올릴 때, 컴파일러가 성능 향상을 위해 추가적인 메모리를 할당하여 끼워 넣는 것
- 내부에 선언된 가장 큰 자료형의 크기로 정해진다
    - 만약 구조체 안에 구조체가 들어있다면, 해당 구조체 안에서 가장 큰 자료형의 크기로 정해진다
    ```cpp
    struct Coord // 8byte
    {
        short U;
        int V;
        // short(2byte) + 2byte / int(4byte)
    }

    struct Texture // 16byte
    {
        char Name;
        short colour;
        Coord coord;
    }
    /**
     * Coord의 제일 큰 타입이 int이므로, 4byte 기준으로 패딩
     * char + short + 1byte / short + 2byte / coord(8byte)
     */
    ```
- 소켓 프로그래밍 중 패킷 구조체를 구현할 때 #pragma pack(push, 1)을 쓰는 이유도 패딩에 있다
- 패킷을 받은 쪽은 패킷을 읽어서 캐스틍일 통해 값을 복구해야 하는데,  
패딩이 들어가 있으면 잘못된 크기를 가지고 캐스팅을 하게 되므로 잘못된 값이 복구되기 때문

## 다형성

### 다형성?
- 객체지향에서 다형성은 여러가지 형태를 가질 수 있는 능력을 의미
- CPP에서의 다형성은 상속에 의한 다형성, Overloading, Overriding, Template에 의한 다형성 등으로 구현된다
    - `Overloading?`
        - 같은 이름의 함수라도 Parameter 타입이 다르거나, 개수가 다르면 다른 함수로 정의하여 사용할 수 있음
        - return 타입은 Overloading과 상관이 없다. return 타입으로는 함수를 구분할 수 없기 때문
    - `Overriding?`
        - 상속관계에서 부모의 메서드를 자식이 재정의해서 사용하는 것
    - `Template?`
        - 클래스, 함수를 타입에 독립적이게 만드는 도구
            - 템플릿을 사용하면 여러 타입에 대응되는 단 하나의 객체나 함수를 만들 수 있다
            - cpp의 기능으로, 함수와 클래스가 제네릭형과 동작할 수 있게 도와준다
            - 함수나 클래스가 개별적으로 다시 작성하지 않고도 각기 다른 수많은 자료형에서 동작할 수 있게 한다
        - 템플릿의 타입은 컴파일 타임에 결정되어 인스턴스화 하기 때문에  
        컴파일 타임에 컴파일러가 실제 코드 구현부를 모두 볼 수 있어야 한다
        - 인스턴스화는 컴파일러가 컴파일 시에 요구되는 타입으로 클래스 정의 코드를 생성해내는 것
            - 즉, 타입을 지정하여 그 타입을 사용하는 클래스를 만들어 냄
            - ex) 만약 float 타입으로 템플릿 클래스를 사용했다면 컴파일 타임에 컴파일러가 float 타입의 클래스를 만들어 냄
            - 그렇기 때문에 템플릿 클래스의 함수 구현은 헤더파일에 들어가야 한다
            - 혹은 헤더에서 템플릿 정의부분 아래에 cpp파일을 include하는 방법도 있지만 cpp파일을 빌드 리스트에 넣지 말아야 한다

## Reference & Pointer

### Reference

## auto
> 기본 특징
- C++11에서 도입된 자동 타입 추론 키워드
- 선언과 동시에 반드시 초기화가 필요
- 컴파일러가 초기화 값을 기반으로 타입을 자동으로 결정

> 주의사항
- 초기화 없이 선언만 하는 것은 불가능
- 한번 타입이 결정되면 다른 타입으로 변경 불가능
- 코드의 가독성을 위해 명확한 상황에서만 사용 권장

## Reference vs Copy
> Reference
- 변수의 별칭(alias)으로 작동
- 직접 메모리 참조 방식 사용
- NULL 초기화 불가능

> Copy와의 차이점
- 레퍼런스는 추가 메모리 공간을 소모하지 않음
- 복사자는 값 복사로 인한 메모리 소모 발생
- 함수 호출 시 레퍼런스 값 복사가 발생하지 않음

## Smart pointer
> Unique_ptr
- 객체의 유일한 소유권 보장
- 자동 메모리 해제 기능
- 소유권 이전 시 MoveTemp() 사용

> Shared_ptr
- 여러 포인터가 하나의 객체 공유 가능
- 참조 카운트 기반 자동 메모리 관리
- 스레드 안전성 보장

> Weak_ptr

## Interface
> 특징과 활용
- 순수 가상 함수로만 구성
- 클래스의 뼈대 역할 수행
- 다중 상속 가능

> 구현 방법
- virtual 키워드와 =0 사용
- 모든 멤버 함수는 public 및 virtual로 선언
- 구현 클래스에서 모든 함수 오버라이딩 필수

## STL 특징
- 템플릿 기반의 일반화된 알고리즘 제공
- 데이터 추상화와 코드 재사용성 향상

## 이터레이터 활용
- 컨테이너 요소에 대한 순차적 접근 제공
- begin()과 end() 함수로 범위 지정
- 포인터와 유사한 방식으로 요소 접근

# 메모리 관리

## 메모리 효율 파악과 최적화 방법

### 기본 원칙
- 불필요한 동적 할당 최소화
- 적절한 메모리 정렬 유지
- 캐시 친화적인 데이터 구조 설계

### 최적화 기법
- 메모리 풀링 활용
- 객체 재사용 패턴 적용
- 메모리 단편화 최소화

## 기본 컨테이너 사용시 주의사항

### vector
- 리사이즈 시 메모리 재할당 비용 고려
- reserve()를 통한 사전 메모리 할당
- shrink_to_fit()으로 불필요 메모리 해제

### list
- 노드 할당/해제 오버헤드 인지
- 캐시 지역성 저하 주의
- 반복자 무효화 상황 파악

### map
- 레드-블랙 트리 구조의 오버헤드
- 잦은 검색 시 unordered_map 고려
- 키 비교 연산 최적화

## 람다와 람다 캡처 고려사항

### 람다 기본
- 캡처 방식에 따른 메모리 영향 이해
- 값 캡처와 참조 캡처의 수명 주기
- 캡처 목록 최소화

### 주의사항
- 참조 캡처 시 댕글링 레퍼런스 방지
- 캡처된 변수의 메모리 관리
- 람다 객체 크기 고려

# 게임 프로그래밍 특화 내용

## 스레드와 뮤텍스

### 스레드 개념
- 프로세스 내에서 실행되는 독립적인 실행 단위
- 메모리 공유를 통한 효율적인 병렬 처리
- 게임에서 렌더링, 물리, AI 등 분리 실행

### 뮤텍스 활용
- 공유 자원 접근 제어 메커니즘
- 데드락 방지를 위한 적절한 락킹 순서 유지
- RAII 패턴을 활용한 안전한 락 관리

## 클래스 상속과 버추얼

### 상속 구조
- 기반 클래스와 파생 클래스의 관계 설계
- 다형성을 통한 유연한 인터페이스 구현
- protected와 private 상속의 적절한 활용

### 버추얼 함수
- 동적 바인딩을 통한 다형성 구현
- 가상 소멸자의 필요성
- 순수 가상 함수와 추상 클래스 활용

## 템플릿 프로그래밍

### 기본 사용법
- 타입 독립적인 코드 작성
- 컴파일 타임 다형성 구현
- 특수화를 통한 최적화

### 주의사항
- 코드 블로트 최소화
- 컴파일 시간 증가 고려
- 명확한 에러 메시지 처리

## 배열과 힙 메모리

### 버퍼 오버런 방지
- 경계 검사 구현
- 스마트 포인터 활용
- 메모리 할당 크기 검증

### 힙 관리
- 메모리 누수 방지
- 단편화 최소화
- 할당/해제 패턴 최적화

## 생성자 종류와 역할

### 기본 생성자
- 멤버 초기화 리스트 활용
- 암시적 변환 방지
- 예외 안전성 보장

### 특수 생성자
- 복사 생성자의 깊은 복사 구현
- 이동 생성자를 통한 리소스 전달
- 변환 생성자의 제한적 사용

# 코드 설계 가이드

## 적절한 컨테이너 선택과 사용법

### 컨테이너 선택 기준
- 데이터 접근 패턴 분석
- 삽입/삭제 빈도 고려
- 메모리 사용량 최적화

### 주요 컨테이너별 활용
- vector: 연속된 메모리, 빠른 순차 접근
- list: 잦은 삽입/삭제 작업
- map: 키-값 쌍의 정렬된 데이터
- unordered_map: 해시 기반 빠른 검색

## 효율성 고려사항

### 성능 최적화
- 불필요한 복사 연산 제거
- 적절한 메모리 할당 전략
- 캐시 친화적 데이터 구조 설계

### 알고리즘 최적화
- 시간 복잡도 분석
- 공간 복잡도 고려
- 병목 지점 식별 및 개선

## 클린 코드 유지 방법

### 코드 구조화
- 단일 책임 원칙 준수
- 의미 있는 네이밍 규칙
- 일관된 코딩 스타일 유지

### 유지보수성
- 적절한 주석 작성
- 모듈화와 재사용성 고려
- 테스트 용이성 확보

# 추가 고려사항

## 상속과 버추얼 매커니즘

### 상속 메커니즘
- 가상 함수 테이블(vtable) 구조 이해
- 다중 상속시 다이아몬드 문제 해결
- 가상 상속의 동작 원리 파악

### 버추얼 매커니즘
- 동적 디스패치 구현 방식
- 가상 함수 호출 비용
- 컴파일러의 최적화 전략

## 스레드와 락 메커니즘

### 커널락
- 운영체제 수준의 동기화
- 컨텍스트 스위칭 오버헤드
- 우선순위 상속 문제

### 스핀락
- 사용자 수준의 동기화
- busy-waiting 특성
- 짧은 임계 영역에 적합

## 복사와 이동 시멘틱

### 복사 연산
- 깊은 복사와 얕은 복사
- 복사 생성자 최적화
- 복사 할당 연산자 구현

### 이동 연산
- 리소스 소유권 이전
- 이동 생성자 구현
- 이동 할당 연산자 활용

---

# 자료구조와 알고리즘 핵심 개념

## 1. 기본 자료구조 특징

### Array
- **특징**: 연속된 메모리 공간에 순차적 저장
- **장점**: 
  - 인덱스를 통한 빠른 접근 (O(1))
  - 메모리 효율적 사용
- **단점**: 
  - 크기 변경 불가
  - 삽입/삭제 시 O(n) 시간 소요
- **용도**: 데이터 크기가 고정적이고 빠른 접근이 필요한 경우

### List
- **특징**: 노드 기반 순차적 데이터 구조
- **장점**: 
  - 삽입/삭제가 용이
  - 동적 크기 조절 가능
- **단점**: 
  - 임의 접근 불가
  - 추가 메모리 공간 필요

### Stack
- **특징**: LIFO(Last In First Out) 구조
- **장점**: 
  - 구현이 간단
  - 메모리 효율적 사용
- **단점**: 데이터 접근의 제한성

### Queue
- **특징**: FIFO(First In First Out) 구조
- **장점**: 
  - 데이터 순서 보장
  - 동시성 처리에 유용
- **단점**: 중간 데이터 접근 불가

## 2. 벡터의 내적과 외적

### 내적(Inner Product)
- **정의**: 두 벡터의 스칼라 곱
- **수식**: A·B = |A||B|cosθ
- **의미**: 한 벡터의 다른 벡터로의 투영

### 외적(Cross Product)
- **정의**: 두 벡터에 수직인 새로운 벡터 생성
- **특징**: 
  - 결과는 벡터
  - 크기는 두 벡터가 만드는 평행사변형의 넓이

## 3. Virtual 함수 동작 과정

### 가상 함수 테이블(V-Table)
- 컴파일러가 가상 함수를 포함하는 클래스에 대해 생성
- 함수 주소 정보를 저장하는 테이블 구조

### 동작 과정
1. 클래스 객체 생성 시 가상 함수 테이블 포인터 추가
2. 가상 함수 호출 시 테이블 참조하여 실제 함수 위치 확인
3. 해당 함수 실행

### 특징
- 런타임에 실제 호출 함수 결정
- 약간의 성능 오버헤드 발생
- 동적 바인딩 지원

# 4. Hash와 Tree의 비교

## 해시 테이블
### 장점
- 삽입, 삭제, 검색 모두 O(1) 시간복잡도
- 빠른 데이터 접근
- 캐시 친화적 구조

### 단점
- 해시 충돌 발생 가능
- 순서/관계가 있는 데이터에 부적합
- 미리 공간 할당 필요

## 트리(BST)
### 장점
- 정렬된 데이터 유지
- 범위 검색 용이
- 필요한 만큼만 메모리 사용

### 단점
- 평균 O(logn), 최악의 경우 O(n) 성능
- 불균형 시 성능 저하
- 추가 메모리 공간 필요

# 5. 조명 모델

## Ambient Light
- 주변 환경에서 반사된 간접 조명
- 광원과 무관하게 일정한 밝기 제공
- 계산: 기본 색상 × 환경광 계수

## Diffuse Light
- 물체 표면에서의 난반사
- 물체에 입체감 부여
- 계산: 법선벡터와 광원 벡터의 내적

## Specular Light
- 정반사 효과 표현
- 물체의 광택감 표현
- 계산: 반사벡터와 시점벡터의 내적의 거듭제곱

## Emissive Light
- 물체 자체의 발광
- 광원에 영향받지 않는 고유 발광
- 계산: 발광 색상 직접 적용

# 6. 3D 그래픽스 파이프라인

## 주요 단계
1. Input Assembler
- CPU에서 정점 데이터 수집
- 정점 버퍼 생성 및 전달

2. Vertex Shader
- 정점 변환 (Local → World → View → Clip Space)
- 정점 데이터 처리

3. Rasterization
- 3D 공간의 정점을 2D 화면으로 변환
- 픽셀 단위로 분할

4. Fragment/Pixel Shader
- 픽셀 색상 계산
- 텍스처 매핑
- 조명 효과 적용

5. Output Merger
- 최종 픽셀 색상 결정
- 깊이/스텐실 테스트
- 화면 출력

# 7. 3D 변환 과정

## World Transform
- 로컬 좌표계에서 월드 좌표계로 변환
- 이동(Translation), 회전(Rotation), 크기(Scale) 변환 포함
- 4x4 행렬로 표현: World = Scale × Rotation × Translation

## View Transform
- 월드 좌표계에서 카메라(뷰) 좌표계로 변환
- 카메라의 위치와 방향 기준으로 모든 객체 변환
- View = Camera Position × Camera Rotation

## Projection Transform
- 3D 공간을 2D 평면으로 투영
- 원근 투영(Perspective)과 직교 투영(Orthographic) 방식
- 시야각(FOV), 종횡비, 근평면, 원평면 고려

# 8. 콜 스택과 스택 오버플로우

## Call Stack
- 함수 호출 정보를 저장하는 메모리 구조
- LIFO(Last In First Out) 방식으로 동작
- 지역 변수, 매개변수, 반환 주소 저장

## Stack Overflow
- 콜 스택의 크기를 초과할 때 발생
- 주요 원인:
  - 무한 재귀 호출
  - 과도한 지역 변수 선언
  - 깊은 함수 호출 중첩

# 9. 메모리 종류

## System Memory (RAM)
- CPU가 직접 접근하는 주 메모리
- 프로그램 실행과 데이터 처리에 사용
- 휘발성 메모리

## Video Memory (VRAM)
- GPU에서 사용하는 전용 메모리
- 텍스처, 프레임 버퍼 저장
- 고속 그래픽 처리 지원

## AGP Memory
- 그래픽 카드와 시스템 메모리 간의 전용 통로
- 텍스처와 그래픽 데이터 고속 전송
- PCI Express로 대체된 레거시 기술
