# CPP
- [auto](#auto)
- [Reference vs Copy](#Reference-vs-Copy)

## auto
> 기본 특징
- C++11에서 도입된 자동 타입 추론 키워드
- 선언과 동시에 반드시 초기화가 필요
- 컴파일러가 초기화 값을 기반으로 타입을 자동으로 결정

> 주의사항
- 초기화 없이 선언만 하는 것은 불가능
- 한번 타입이 결정되면 다른 타입으로 변경 불가능
- 코드의 가독성을 위해 명확한 상황에서만 사용 권장

## Reference vs Copy
> Reference
- 변수의 별칭(alias)으로 작동
- 직접 메모리 참조 방식 사용
- NULL 초기화 불가능

> Copy와의 차이점
- 레퍼런스는 추가 메모리 공간을 소모하지 않음
- 복사자는 값 복사로 인한 메모리 소모 발생
- 함수 호출 시 레퍼런스 값 복사가 발생하지 않음

## Smart pointer
> Unique_ptr
- 객체의 유일한 소유권 보장
- 자동 메모리 해제 기능
- 소유권 이전 시 MoveTemp() 사용

> Shared_ptr
- 여러 포인터가 하나의 객체 공유 가능
- 참조 카운트 기반 자동 메모리 관리
- 스레드 안전성 보장

> Weak_ptr

## Interface
> 특징과 활용
- 순수 가상 함수로만 구성
- 클래스의 뼈대 역할 수행
- 다중 상속 가능

> 구현 방법
- virtual 키워드와 =0 사용
- 모든 멤버 함수는 public 및 virtual로 선언
- 구현 클래스에서 모든 함수 오버라이딩 필수

## STL 특징
- 템플릿 기반의 일반화된 알고리즘 제공
- 데이터 추상화와 코드 재사용성 향상

## 이터레이터 활용
- 컨테이너 요소에 대한 순차적 접근 제공
- begin()과 end() 함수로 범위 지정
- 포인터와 유사한 방식으로 요소 접근

# 메모리 관리

## 메모리 효율 파악과 최적화 방법

### 기본 원칙
- 불필요한 동적 할당 최소화
- 적절한 메모리 정렬 유지
- 캐시 친화적인 데이터 구조 설계

### 최적화 기법
- 메모리 풀링 활용
- 객체 재사용 패턴 적용
- 메모리 단편화 최소화

## 기본 컨테이너 사용시 주의사항

### vector
- 리사이즈 시 메모리 재할당 비용 고려
- reserve()를 통한 사전 메모리 할당
- shrink_to_fit()으로 불필요 메모리 해제

### list
- 노드 할당/해제 오버헤드 인지
- 캐시 지역성 저하 주의
- 반복자 무효화 상황 파악

### map
- 레드-블랙 트리 구조의 오버헤드
- 잦은 검색 시 unordered_map 고려
- 키 비교 연산 최적화

## 람다와 람다 캡처 고려사항

### 람다 기본
- 캡처 방식에 따른 메모리 영향 이해
- 값 캡처와 참조 캡처의 수명 주기
- 캡처 목록 최소화

### 주의사항
- 참조 캡처 시 댕글링 레퍼런스 방지
- 캡처된 변수의 메모리 관리
- 람다 객체 크기 고려

# 게임 프로그래밍 특화 내용

## 스레드와 뮤텍스

### 스레드 개념
- 프로세스 내에서 실행되는 독립적인 실행 단위
- 메모리 공유를 통한 효율적인 병렬 처리
- 게임에서 렌더링, 물리, AI 등 분리 실행

### 뮤텍스 활용
- 공유 자원 접근 제어 메커니즘
- 데드락 방지를 위한 적절한 락킹 순서 유지
- RAII 패턴을 활용한 안전한 락 관리

## 클래스 상속과 버추얼

### 상속 구조
- 기반 클래스와 파생 클래스의 관계 설계
- 다형성을 통한 유연한 인터페이스 구현
- protected와 private 상속의 적절한 활용

### 버추얼 함수
- 동적 바인딩을 통한 다형성 구현
- 가상 소멸자의 필요성
- 순수 가상 함수와 추상 클래스 활용

## 템플릿 프로그래밍

### 기본 사용법
- 타입 독립적인 코드 작성
- 컴파일 타임 다형성 구현
- 특수화를 통한 최적화

### 주의사항
- 코드 블로트 최소화
- 컴파일 시간 증가 고려
- 명확한 에러 메시지 처리

## 배열과 힙 메모리

### 버퍼 오버런 방지
- 경계 검사 구현
- 스마트 포인터 활용
- 메모리 할당 크기 검증

### 힙 관리
- 메모리 누수 방지
- 단편화 최소화
- 할당/해제 패턴 최적화

## 생성자 종류와 역할

### 기본 생성자
- 멤버 초기화 리스트 활용
- 암시적 변환 방지
- 예외 안전성 보장

### 특수 생성자
- 복사 생성자의 깊은 복사 구현
- 이동 생성자를 통한 리소스 전달
- 변환 생성자의 제한적 사용

# 코드 설계 가이드

## 적절한 컨테이너 선택과 사용법

### 컨테이너 선택 기준
- 데이터 접근 패턴 분석
- 삽입/삭제 빈도 고려
- 메모리 사용량 최적화

### 주요 컨테이너별 활용
- vector: 연속된 메모리, 빠른 순차 접근
- list: 잦은 삽입/삭제 작업
- map: 키-값 쌍의 정렬된 데이터
- unordered_map: 해시 기반 빠른 검색

## 효율성 고려사항

### 성능 최적화
- 불필요한 복사 연산 제거
- 적절한 메모리 할당 전략
- 캐시 친화적 데이터 구조 설계

### 알고리즘 최적화
- 시간 복잡도 분석
- 공간 복잡도 고려
- 병목 지점 식별 및 개선

## 클린 코드 유지 방법

### 코드 구조화
- 단일 책임 원칙 준수
- 의미 있는 네이밍 규칙
- 일관된 코딩 스타일 유지

### 유지보수성
- 적절한 주석 작성
- 모듈화와 재사용성 고려
- 테스트 용이성 확보

# 추가 고려사항

## 상속과 버추얼 매커니즘

### 상속 메커니즘
- 가상 함수 테이블(vtable) 구조 이해
- 다중 상속시 다이아몬드 문제 해결
- 가상 상속의 동작 원리 파악

### 버추얼 매커니즘
- 동적 디스패치 구현 방식
- 가상 함수 호출 비용
- 컴파일러의 최적화 전략

## 스레드와 락 메커니즘

### 커널락
- 운영체제 수준의 동기화
- 컨텍스트 스위칭 오버헤드
- 우선순위 상속 문제

### 스핀락
- 사용자 수준의 동기화
- busy-waiting 특성
- 짧은 임계 영역에 적합

## 복사와 이동 시멘틱

### 복사 연산
- 깊은 복사와 얕은 복사
- 복사 생성자 최적화
- 복사 할당 연산자 구현

### 이동 연산
- 리소스 소유권 이전
- 이동 생성자 구현
- 이동 할당 연산자 활용
