# 게임 프로그래밍 특화 내용

## 스레드와 뮤텍스

### 스레드 개념
- 프로세스 내에서 실행되는 독립적인 실행 단위
- 메모리 공유를 통한 효율적인 병렬 처리
- 게임에서 렌더링, 물리, AI 등 분리 실행

### 뮤텍스 활용
- 공유 자원 접근 제어 메커니즘
- 데드락 방지를 위한 적절한 락킹 순서 유지
- RAII 패턴을 활용한 안전한 락 관리

## 클래스 상속과 버추얼

### 상속 구조
- 기반 클래스와 파생 클래스의 관계 설계
- 다형성을 통한 유연한 인터페이스 구현
- protected와 private 상속의 적절한 활용

### 버추얼 함수
- 동적 바인딩을 통한 다형성 구현
- 가상 소멸자의 필요성
- 순수 가상 함수와 추상 클래스 활용

## 템플릿 프로그래밍

### 기본 사용법
- 타입 독립적인 코드 작성
- 컴파일 타임 다형성 구현
- 특수화를 통한 최적화

### 주의사항
- 코드 블로트 최소화
- 컴파일 시간 증가 고려
- 명확한 에러 메시지 처리

## 배열과 힙 메모리

### 버퍼 오버런 방지
- 경계 검사 구현
- 스마트 포인터 활용
- 메모리 할당 크기 검증

### 힙 관리
- 메모리 누수 방지
- 단편화 최소화
- 할당/해제 패턴 최적화

## 생성자 종류와 역할

### 기본 생성자
- 멤버 초기화 리스트 활용
- 암시적 변환 방지
- 예외 안전성 보장

### 특수 생성자
- 복사 생성자의 깊은 복사 구현
- 이동 생성자를 통한 리소스 전달
- 변환 생성자의 제한적 사용

# 코드 설계 가이드

## 적절한 컨테이너 선택과 사용법

### 컨테이너 선택 기준
- 데이터 접근 패턴 분석
- 삽입/삭제 빈도 고려
- 메모리 사용량 최적화

### 주요 컨테이너별 활용
- vector: 연속된 메모리, 빠른 순차 접근
- list: 잦은 삽입/삭제 작업
- map: 키-값 쌍의 정렬된 데이터
- unordered_map: 해시 기반 빠른 검색

## 효율성 고려사항

### 성능 최적화
- 불필요한 복사 연산 제거
- 적절한 메모리 할당 전략
- 캐시 친화적 데이터 구조 설계

### 알고리즘 최적화
- 시간 복잡도 분석
- 공간 복잡도 고려
- 병목 지점 식별 및 개선

## 클린 코드 유지 방법

### 코드 구조화
- 단일 책임 원칙 준수
- 의미 있는 네이밍 규칙
- 일관된 코딩 스타일 유지

### 유지보수성
- 적절한 주석 작성
- 모듈화와 재사용성 고려
- 테스트 용이성 확보

# 추가 고려사항

## 상속과 버추얼 매커니즘

### 상속 메커니즘
- 가상 함수 테이블(vtable) 구조 이해
- 다중 상속시 다이아몬드 문제 해결
- 가상 상속의 동작 원리 파악

### 버추얼 매커니즘
- 동적 디스패치 구현 방식
- 가상 함수 호출 비용
- 컴파일러의 최적화 전략

## 스레드와 락 메커니즘

### 커널락
- 운영체제 수준의 동기화
- 컨텍스트 스위칭 오버헤드
- 우선순위 상속 문제

### 스핀락
- 사용자 수준의 동기화
- busy-waiting 특성
- 짧은 임계 영역에 적합

## 복사와 이동 시멘틱

### 복사 연산
- 깊은 복사와 얕은 복사
- 복사 생성자 최적화
- 복사 할당 연산자 구현

### 이동 연산
- 리소스 소유권 이전
- 이동 생성자 구현
- 이동 할당 연산자 활용

---

## 2. 벡터의 내적과 외적

### 내적(Inner Product)
- **정의**: 두 벡터의 스칼라 곱
- **수식**: A·B = |A||B|cosθ
- **의미**: 한 벡터의 다른 벡터로의 투영

### 외적(Cross Product)
- **정의**: 두 벡터에 수직인 새로운 벡터 생성
- **특징**: 
  - 결과는 벡터
  - 크기는 두 벡터가 만드는 평행사변형의 넓이

## 3. Virtual 함수 동작 과정

### 가상 함수 테이블(V-Table)
- 컴파일러가 가상 함수를 포함하는 클래스에 대해 생성
- 함수 주소 정보를 저장하는 테이블 구조

### 동작 과정
1. 클래스 객체 생성 시 가상 함수 테이블 포인터 추가
2. 가상 함수 호출 시 테이블 참조하여 실제 함수 위치 확인
3. 해당 함수 실행

### 특징
- 런타임에 실제 호출 함수 결정
- 약간의 성능 오버헤드 발생
- 동적 바인딩 지원

# 4. Hash와 Tree의 비교

## 해시 테이블
### 장점
- 삽입, 삭제, 검색 모두 O(1) 시간복잡도
- 빠른 데이터 접근
- 캐시 친화적 구조

### 단점
- 해시 충돌 발생 가능
- 순서/관계가 있는 데이터에 부적합
- 미리 공간 할당 필요

## 트리(BST)
### 장점
- 정렬된 데이터 유지
- 범위 검색 용이
- 필요한 만큼만 메모리 사용

### 단점
- 평균 O(logn), 최악의 경우 O(n) 성능
- 불균형 시 성능 저하
- 추가 메모리 공간 필요

# 5. 조명 모델

## Ambient Light
- 주변 환경에서 반사된 간접 조명
- 광원과 무관하게 일정한 밝기 제공
- 계산: 기본 색상 × 환경광 계수

## Diffuse Light
- 물체 표면에서의 난반사
- 물체에 입체감 부여
- 계산: 법선벡터와 광원 벡터의 내적

## Specular Light
- 정반사 효과 표현
- 물체의 광택감 표현
- 계산: 반사벡터와 시점벡터의 내적의 거듭제곱

## Emissive Light
- 물체 자체의 발광
- 광원에 영향받지 않는 고유 발광
- 계산: 발광 색상 직접 적용

# 6. 3D 그래픽스 파이프라인

## 주요 단계
1. Input Assembler
- CPU에서 정점 데이터 수집
- 정점 버퍼 생성 및 전달

2. Vertex Shader
- 정점 변환 (Local → World → View → Clip Space)
- 정점 데이터 처리

3. Rasterization
- 3D 공간의 정점을 2D 화면으로 변환
- 픽셀 단위로 분할

4. Fragment/Pixel Shader
- 픽셀 색상 계산
- 텍스처 매핑
- 조명 효과 적용

5. Output Merger
- 최종 픽셀 색상 결정
- 깊이/스텐실 테스트
- 화면 출력

# 7. 3D 변환 과정

## World Transform
- 로컬 좌표계에서 월드 좌표계로 변환
- 이동(Translation), 회전(Rotation), 크기(Scale) 변환 포함
- 4x4 행렬로 표현: World = Scale × Rotation × Translation

## View Transform
- 월드 좌표계에서 카메라(뷰) 좌표계로 변환
- 카메라의 위치와 방향 기준으로 모든 객체 변환
- View = Camera Position × Camera Rotation

## Projection Transform
- 3D 공간을 2D 평면으로 투영
- 원근 투영(Perspective)과 직교 투영(Orthographic) 방식
- 시야각(FOV), 종횡비, 근평면, 원평면 고려

# 8. 콜 스택과 스택 오버플로우

## Call Stack
- 함수 호출 정보를 저장하는 메모리 구조
- LIFO(Last In First Out) 방식으로 동작
- 지역 변수, 매개변수, 반환 주소 저장

## Stack Overflow
- 콜 스택의 크기를 초과할 때 발생
- 주요 원인:
  - 무한 재귀 호출
  - 과도한 지역 변수 선언
  - 깊은 함수 호출 중첩

# 9. 메모리 종류

## System Memory (RAM)
- CPU가 직접 접근하는 주 메모리
- 프로그램 실행과 데이터 처리에 사용
- 휘발성 메모리

## Video Memory (VRAM)
- GPU에서 사용하는 전용 메모리
- 텍스처, 프레임 버퍼 저장
- 고속 그래픽 처리 지원

## AGP Memory
- 그래픽 카드와 시스템 메모리 간의 전용 통로
- 텍스처와 그래픽 데이터 고속 전송
- PCI Express로 대체된 레거시 기술
